<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NiceLeeのBlog</title>
    <description>NiceLee的个人博客</description>
    <link>https://nicelee.top/</link>
    <atom:link href="https://nicelee.top/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 03 Feb 2023 20:37:09 +0800</pubDate>
    <lastBuildDate>Fri, 03 Feb 2023 20:37:09 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Windows下打开文件夹的加速技巧</title>
        <description>
主要是默认为常规文件夹，以及去除文件预览
</description>
        <pubDate>Fri, 03 Feb 2023 09:59:01 +0800</pubDate>
        <pubDateFormat>2023-02-03</pubDateFormat>
        <link>https://nicelee.top/blog/2023/02/03/win-speed-up/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2023/02/03/win-speed-up/</guid>
        
        <category>Windows</category>
        
        
        <category>小技巧</category>
        
      </item>
    
      <item>
        <title>Go 在Web框架中嵌入伪装数据流</title>
        <description>
总的来说，经典的Web框架会将每个HTTP请求回复抽象为两部分： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Request&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Response&lt;/code&gt;。&lt;br /&gt;
其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Request&lt;/code&gt;包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Method&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP Version&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Url&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Headers&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;等；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Response&lt;/code&gt;包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Status&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Headers&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;等等。&lt;br /&gt;
像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cookie&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User-Agent&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Query/Post参数&lt;/code&gt;等则更加细节，是对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Url&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Headers&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;的进一步处理。

但有一个问题，这些框架的逻辑，每一次请求更加像是单向的数据流。Client每一次将请求发送(至少是除了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;以外的部分)给Server端完毕后，Server端再处理给出回应。

像特殊情况，上传超大文件这种，一般都是要自己实现的，主要是针对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Request&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;进行一些解析实现。
不过虽然开始处理时没有收到完整的数据，但是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;的大小其实在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-length&lt;/code&gt;里是已知的。Server也是在保存文件成功或者失败以后再给Client答复。

&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Request&lt;/code&gt;的Body大小一般来说是已知的，写在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-length&lt;/code&gt;里，当然也可以未知，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transfer-Encoding: Chunked&lt;/code&gt;通过指示每一份内容来做分割和控制，不过极其少见，估计也没多少场景中会用到这个。

&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Response&lt;/code&gt;的Body大小一般来说也是已知的，写在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-length&lt;/code&gt;里，当然也可以未知，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transfer-Encoding: Chunked&lt;/code&gt;一段一段的写。

(&lt;del&gt;当然http2里面这个被禁止使用了，详见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding&quot;&gt;MDN&lt;/a&gt;&lt;/del&gt;)

是的，理论上你可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chunked&lt;/code&gt;+ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chunked&lt;/code&gt;来实现一个双向数据流，至少本地可以跑通。但是会有缺陷，就像TCP的粘包一样，中间层可能会缓存&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chunked0&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chunked1&lt;/code&gt;、…&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChunkedN&lt;/code&gt;甚至等到结尾再传给你。
毕竟逻辑上的普遍情况是Server端收到完整&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Request&lt;/code&gt;后，再返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Response&lt;/code&gt;，之后当次HTTP请求算是跑完了一整个流程。

我们考虑以下场景：
&lt;ul&gt;
  &lt;li&gt;Client发送 cChunked0，cChunked1&lt;/li&gt;
  &lt;li&gt;Server接收到 cChunked0，cChunked1，处理后返回 sChunked0、sChunked1&lt;/li&gt;
  &lt;li&gt;Client接收到 sChunked0、sChunked1，处理后再发送 cChunked2，cChunked结束边界&lt;/li&gt;
  &lt;li&gt;Server接收到 cChunked2，cChunked结束边界, 处理后返回sChunked结束边界&lt;/li&gt;
  &lt;li&gt;HTTP请求结束&lt;/li&gt;
&lt;/ul&gt;

实际上，可能在上述第二步和第三步就会卡住，无法实现。

所以，讲这么多最简单的还是Websocket。 通过Client通过HTTP GET附带&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Upgrade&lt;/code&gt;请求, Server 回复 101消息表示请求升级。接下来则完全不必按照Websocket来了，因为中间层不会浪费资源去解析或截留缓存接下来的内容。
</description>
        <pubDate>Wed, 01 Feb 2023 09:59:01 +0800</pubDate>
        <pubDateFormat>2023-02-01</pubDateFormat>
        <link>https://nicelee.top/blog/2023/02/01/go-http-hijack/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2023/02/01/go-http-hijack/</guid>
        
        <category>Go</category>
        
        <category>代理</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>备忘录 关于tauri的二三事</title>
        <description>
&lt;a href=&quot;https://tauri.app/v1/guides/debugging/application&quot;&gt;官方文档&lt;/a&gt;已经整理得挺好的，这里额外补充一些注意事项
</description>
        <pubDate>Tue, 03 Jan 2023 09:59:01 +0800</pubDate>
        <pubDateFormat>2023-01-03</pubDateFormat>
        <link>https://nicelee.top/blog/2023/01/03/tauri-demo/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2023/01/03/tauri-demo/</guid>
        
        <category>Rust</category>
        
        <category>tauri</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>备忘录 关于Firefox的二三事</title>
        <description>&lt;blockquote&gt;
  有两个使用场景：
  &lt;ul&gt;
    &lt;li&gt;PC端禁止火狐更新已经有2年了，现在想升一下级(然后再禁止😳)。&lt;/li&gt;
    &lt;li&gt;Android端使用Beta版本，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;about:config&lt;/code&gt;设置DoH，绕过某些DNS污染(主要是不需要开其它的东西，也不是手机的全局配置，省电)。&lt;/li&gt;
  &lt;/ul&gt;

  正好有点关联（都是火狐），放在一起做个笔记。
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 27 Dec 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-12-27</pubDateFormat>
        <link>https://nicelee.top/blog/2022/12/27/sth-about-mozilla-firefox/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/12/27/sth-about-mozilla-firefox/</guid>
        
        <category>DNS</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>Rust 入门时容易迷惑的技术细节(macro篇)</title>
        <description>&lt;blockquote&gt;
  接上文。
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 01 Dec 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-12-01</pubDateFormat>
        <link>https://nicelee.top/blog/2022/12/01/rust-sth-about-marco/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/12/01/rust-sth-about-marco/</guid>
        
        <category>Rust</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>Rust 入门时容易迷惑的技术细节(trait篇)</title>
        <description>&lt;blockquote&gt;
  在入门的时候并不能全方位地看待问题，有时候会忽略一些显而易见的知识，现在回过头梳理，把前面的补起来。
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 27 Nov 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-11-27</pubDateFormat>
        <link>https://nicelee.top/blog/2022/11/27/rust-sth-about-trait/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/11/27/rust-sth-about-trait/</guid>
        
        <category>Rust</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>Rust 使用wasm实现path签名sign</title>
        <description>&lt;blockquote&gt;
  一般网络请求的path后面都会跟一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;sign=...&lt;/code&gt;，用于验证该request的合法性。&lt;br /&gt;
通常情况下，这个步骤是隐藏在各种js加密混淆里的。  &lt;br /&gt;
这里，我们尝试使用wasm将该步骤实现。
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 25 Nov 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-11-25</pubDateFormat>
        <link>https://nicelee.top/blog/2022/11/25/rust-wasm-digest/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/11/25/rust-wasm-digest/</guid>
        
        <category>Rust</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>Rust 比较时差大小犯的错误😳</title>
        <description>&lt;blockquote&gt;
  时间戳是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u128&lt;/code&gt;类型，unsigned无符号，这个问题卡了我很久，就很郁闷。
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 24 Nov 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-11-24</pubDateFormat>
        <link>https://nicelee.top/blog/2022/11/24/rust-compare-unsigned/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/11/24/rust-compare-unsigned/</guid>
        
        <category>Rust</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>Rust 交叉编译</title>
        <description>&lt;blockquote&gt;
  如何编译不同平台的可执行程序？
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 23 Nov 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-11-23</pubDateFormat>
        <link>https://nicelee.top/blog/2022/11/23/rust-cross-compile/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/11/23/rust-cross-compile/</guid>
        
        <category>Rust</category>
        
        
        <category>技术学习</category>
        
      </item>
    
      <item>
        <title>Rust 利用HTTPS WebSocket通道转发流量</title>
        <description>&lt;blockquote&gt;
  前面我们已经实现了HTTP(S)代理。  &lt;br /&gt;
该代理获得(host,port)后，是尝试直接与目的socket建立连接。&lt;br /&gt;
假设我们在远端有一台服务器。&lt;br /&gt;
我们想代理在获得(host,port)后，与服务器建立连接，并告知它(host,port)。&lt;br /&gt;
由服务器建立与目的socket建立连接，继而充当管道工，转发各自流量。
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 15 Nov 2022 09:59:01 +0800</pubDate>
        <pubDateFormat>2022-11-15</pubDateFormat>
        <link>https://nicelee.top/blog/2022/11/15/rust-async-websocket/</link>
        <guid isPermaLink="true">https://nicelee.top/blog/2022/11/15/rust-async-websocket/</guid>
        
        <category>Rust</category>
        
        
        <category>技术学习</category>
        
      </item>
    
  </channel>
</rss>
